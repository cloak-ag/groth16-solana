//! Verification key parser for build.rs usage.
//!
//! This module provides utilities to parse verification key JSON files
//! (generated by zkSNARK tooling) and convert them to Rust source code
//! for use with the Groth16 verifier.
//!
//! # Example
//!
//! ```rust,ignore
//! use groth16_solana::vk_parser::generate_vk_file;
//!
//! fn main() {
//!     generate_vk_file(
//!         "verification_key.json",
//!         "src",
//!         "verifying_key.rs"
//!     ).unwrap();
//! }
//! ```

use num_bigint::BigUint;
use serde::Deserialize;
use std::fs;
use std::path::Path;

/// Errors that can occur during verification key parsing
#[derive(Debug, thiserror::Error)]
pub enum VkParseError {
    #[error("Failed to read file: {0}")]
    IoError(#[from] std::io::Error),

    #[error("Failed to parse JSON: {0}")]
    JsonError(#[from] serde_json::Error),

    #[error("Invalid verification key data: {0}")]
    InvalidData(String),
}

/// Raw verification key data as it appears in JSON files
#[derive(Debug, Deserialize)]
struct RawVerifyingKey {
    #[serde(rename = "vk_alpha_1")]
    vk_alpha_1: Vec<String>,

    #[serde(rename = "vk_beta_2")]
    vk_beta_2: Vec<Vec<String>>,

    #[serde(rename = "vk_gamma_2")]
    vk_gamma_2: Vec<Vec<String>>,

    #[serde(rename = "vk_delta_2")]
    vk_delta_2: Vec<Vec<String>>,

    #[serde(rename = "IC")]
    ic: Vec<Vec<String>>,
}

/// Convert a bigint string to little-endian bytes, then reverse to big-endian
fn bigint_string_to_be_bytes(s: &str, size: usize) -> Result<Vec<u8>, VkParseError> {
    let bigint = s
        .parse::<BigUint>()
        .map_err(|e| VkParseError::InvalidData(format!("Failed to parse bigint '{}': {}", s, e)))?;

    let le_bytes = bigint.to_bytes_le();

    // Pad to desired size
    let mut padded = le_bytes;
    padded.resize(size, 0);

    // Reverse to get big-endian
    padded.reverse();
    Ok(padded)
}

/// Process G1 point: convert bigint to 32-byte BE
fn process_g1_component(component: &str) -> Result<Vec<u8>, VkParseError> {
    bigint_string_to_be_bytes(component, 32)
}

/// Process G2 point: concatenate two 32-byte LE components, reverse the full 64 bytes, then split
fn process_g2_component(components: &[String]) -> Result<(Vec<u8>, Vec<u8>), VkParseError> {
    if components.len() != 2 {
        return Err(VkParseError::InvalidData(format!(
            "G2 component must have exactly 2 elements, got {}",
            components.len()
        )));
    }

    // Convert to LE bytes
    let c0_le = components[0]
        .parse::<BigUint>()
        .map_err(|e| VkParseError::InvalidData(format!("Failed to parse bigint: {}", e)))?
        .to_bytes_le();
    let c1_le = components[1]
        .parse::<BigUint>()
        .map_err(|e| VkParseError::InvalidData(format!("Failed to parse bigint: {}", e)))?
        .to_bytes_le();

    // Pad to 32 bytes
    let mut c0_padded = c0_le;
    c0_padded.resize(32, 0);
    let mut c1_padded = c1_le;
    c1_padded.resize(32, 0);

    // Concatenate and reverse
    let mut concat = Vec::new();
    concat.extend_from_slice(&c0_padded);
    concat.extend_from_slice(&c1_padded);
    concat.reverse();

    // Split back
    let part0 = concat[0..32].to_vec();
    let part1 = concat[32..64].to_vec();

    Ok((part0, part1))
}

/// Parse verification key JSON and generate Rust source code as a String
///
/// # Arguments
///
/// * `json_content` - The JSON content as a string
///
/// # Returns
///
/// A String containing the generated Rust code defining a `Groth16Verifyingkey` constant
pub fn parse_vk_json_to_rust_string(json_content: &str) -> Result<String, VkParseError> {
    let raw_vk: RawVerifyingKey = serde_json::from_str(json_content)?;

    let mut output = String::new();

    // Header
    output.push_str("use groth16_solana::groth16::Groth16Verifyingkey;\n\n");
    output.push_str(&format!(
        "pub const VERIFYINGKEY: Groth16Verifyingkey = Groth16Verifyingkey {{\n\tnr_pubinputs: {},\n\n",
        raw_vk.ic.len() - 1
    ));

    // Process vk_alpha_g1 - flat [u8; 64]
    output.push_str("\tvk_alpha_g1: [");
    let mut alpha_bytes = Vec::new();
    for i in 0..raw_vk.vk_alpha_1.len() - 1 {
        let bytes = process_g1_component(&raw_vk.vk_alpha_1[i])?;
        alpha_bytes.extend_from_slice(&bytes);
    }
    output.push_str(
        &alpha_bytes
            .iter()
            .map(|b| format!("{}u8", b))
            .collect::<Vec<_>>()
            .join(", "),
    );
    output.push_str("],\n\n");

    // Process vk_beta_g2 - flat [u8; 128]
    output.push_str("\tvk_beta_g2: [");
    let mut beta_bytes = Vec::new();
    for i in 0..raw_vk.vk_beta_2.len() - 1 {
        let (part0, part1) = process_g2_component(&raw_vk.vk_beta_2[i])?;
        beta_bytes.extend_from_slice(&part0);
        beta_bytes.extend_from_slice(&part1);
    }
    output.push_str(
        &beta_bytes
            .iter()
            .map(|b| format!("{}u8", b))
            .collect::<Vec<_>>()
            .join(", "),
    );
    output.push_str("],\n\n");

    // Process vk_gamma_g2 - flat [u8; 128]
    output.push_str("\tvk_gamma_g2: [");
    let mut gamma_bytes = Vec::new();
    for i in 0..raw_vk.vk_gamma_2.len() - 1 {
        let (part0, part1) = process_g2_component(&raw_vk.vk_gamma_2[i])?;
        gamma_bytes.extend_from_slice(&part0);
        gamma_bytes.extend_from_slice(&part1);
    }
    output.push_str(
        &gamma_bytes
            .iter()
            .map(|b| format!("{}u8", b))
            .collect::<Vec<_>>()
            .join(", "),
    );
    output.push_str("],\n\n");

    // Process vk_delta_g2 - flat [u8; 128]
    output.push_str("\tvk_delta_g2: [");
    let mut delta_bytes = Vec::new();
    for i in 0..raw_vk.vk_delta_2.len() - 1 {
        let (part0, part1) = process_g2_component(&raw_vk.vk_delta_2[i])?;
        delta_bytes.extend_from_slice(&part0);
        delta_bytes.extend_from_slice(&part1);
    }
    output.push_str(
        &delta_bytes
            .iter()
            .map(|b| format!("{}u8", b))
            .collect::<Vec<_>>()
            .join(", "),
    );
    output.push_str("],\n\n");

    // Process vk_ic - &[[u8; 64]]
    output.push_str("\tvk_ic: &[\n");
    for point in &raw_vk.ic {
        output.push_str("\t\t[");
        let mut point_bytes = Vec::new();
        for i in 0..point.len() - 1 {
            let bytes = process_g1_component(&point[i])?;
            point_bytes.extend_from_slice(&bytes);
        }
        output.push_str(
            &point_bytes
                .iter()
                .map(|b| format!("{}u8", b))
                .collect::<Vec<_>>()
                .join(", "),
        );
        output.push_str("],\n");
    }
    output.push_str("\t]\n");

    output.push_str("};\n");

    Ok(output)
}

/// Generate a verification key Rust file from a JSON file
///
/// This is a convenience wrapper that reads the JSON file, parses it,
/// and writes the generated Rust code to the specified output location.
///
/// # Arguments
///
/// * `json_path` - Path to the input JSON file containing the verification key
/// * `output_dir` - Directory where the output Rust file will be written
/// * `output_filename` - Name of the output Rust file (e.g., "verifying_key.rs")
///
/// # Example
///
/// ```rust,ignore
/// // In build.rs
/// use groth16_solana::vk_parser::generate_vk_file;
///
/// fn main() {
///     generate_vk_file(
///         "verification_key.json",
///         "src",
///         "verifying_key.rs"
///     ).unwrap();
/// }
/// ```
pub fn generate_vk_file(
    json_path: impl AsRef<Path>,
    output_dir: impl AsRef<Path>,
    output_filename: &str,
) -> Result<(), VkParseError> {
    // Read JSON file
    let json_content = fs::read_to_string(json_path.as_ref())?;

    // Parse and generate Rust code
    let rust_code = parse_vk_json_to_rust_string(&json_content)?;

    // Create output directory if it doesn't exist
    fs::create_dir_all(output_dir.as_ref())?;

    // Write output file
    let output_path = output_dir.as_ref().join(output_filename);
    fs::write(output_path, rust_code)?;

    Ok(())
}
