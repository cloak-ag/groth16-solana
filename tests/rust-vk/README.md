# groth16-solana Integration Test with Rust VK Parser

This integration test demonstrates the complete workflow for using `groth16-solana` with the Rust verification key parser:

1. Compile a circom circuit
2. Generate proving and verification keys
3. Use the Rust VK parser (via `build.rs`) to generate the verifying key Rust code
4. Generate a proof
5. Verify the proof using `groth16-solana`

## Prerequisites

- Rust (latest stable)
- Node.js and npm
- circom (install with `npm install -g circom`)

## Setup

1. Install dependencies and download powers of tau:

```bash
npm run setup
```

2. Compile the circuit and generate keys:

```bash
npm run build-all
```

This will:
- Compile the circom circuit to R1CS and WASM
- Run the Groth16 trusted setup
- Contribute entropy to the ceremony
- Export the verification key JSON

## Running the Test

The test will automatically use the generated verification key via the `build.rs` script:

```bash
cargo test
```

## How It Works

### Build Process

The `build.rs` script does two things:

1. **Generates Verification Key Rust Code**:
   - Reads `build/verification_key.json`
   - Uses `groth16_solana::vk_parser::generate_vk_file()` to convert it to Rust
   - Outputs `src/verifying_key.rs` containing the `VERIFYINGKEY` constant

2. **Transpiles Witness Generator**:
   - Converts the WASM witness generator to a native Rust library
   - Links it for use with `circom-prover`

### Test Flow

The integration test (`src/lib.rs`):

1. Creates a compressed account and Merkle proof inputs
2. Generates a Groth16 proof using `circom-prover`
3. Converts the proof to the format expected by `groth16-solana`
4. Verifies the proof using `Groth16Verifier` with the generated `VERIFYINGKEY`

## Project Structure

```
tests/rust-vk/
├── build/                    # Generated circuit files
│   ├── compressed_account_merkle_proof.r1cs
│   ├── compressed_account_merkle_proof_js/  # WASM witness generator
│   ├── compressed_account_merkle_proof_final.zkey
│   └── verification_key.json
├── circuits/
│   └── compressed_account_merkle_proof.circom
├── pot/
│   └── powersOfTau28_hez_final_16.ptau
├── scripts/
│   └── setup.sh
├── src/
│   ├── lib.rs              # Integration test
│   └── verifying_key.rs    # Generated by build.rs
├── build.rs                # Uses groth16-solana VK parser
├── Cargo.toml
└── package.json
```

## Key Features Demonstrated

1. **Rust VK Parser Integration**: Shows how to use the `vk` feature of `groth16-solana` in `build.rs`
2. **Complete Circuit Workflow**: From circom source to verified proof
3. **Proof Format Conversion**: Demonstrates converting between circom-prover and groth16-solana formats
4. **Build-time Code Generation**: Verification key is generated at compile time

## Troubleshooting

### "Verification key JSON not found"

Run `npm run build-all` to generate the circuit artifacts.

### "Witness WASM not found"

Run `npm run compile` to compile the circuit.

### Verification fails

Ensure you've run the full setup and the verification key matches the proving key:
```bash
npm run clean
npm run build-all
cargo clean
cargo test
```

## Notes

- The circuit uses a 26-level Merkle tree for compressed account proofs
- The powers of tau ceremony file supports circuits up to 2^16 constraints
- The verification key is regenerated whenever `build/verification_key.json` changes
