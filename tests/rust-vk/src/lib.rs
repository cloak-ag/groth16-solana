#![allow(unused)]
use circom_prover::{prover::ProofLib, witness::WitnessFn, CircomProver};
use groth16_solana::groth16::Groth16Verifier;
use groth16_solana::proof_parser::circom_prover::{convert_proof, convert_public_inputs};
use light_compressed_account::compressed_account::{CompressedAccount, CompressedAccountData};
use light_compressed_account::Pubkey;
use light_hasher::{hash_to_field_size::hash_to_bn254_field_size_be, Poseidon};
use light_merkle_tree_reference::MerkleTree;
use num_bigint::BigUint;
use std::collections::HashMap;

// Link the generated witness library
#[link(name = "circuit", kind = "static")]
extern "C" {}

// Declare the witness function
rust_witness::witness!(compressedaccountmerkleproof);

// Include the generated verifying key
// This will be generated by build.rs from the verification_key.json
mod verifying_key;

use verifying_key::VERIFYINGKEY;

/// Helper function to add compressed account inputs to the circuit inputs HashMap
fn add_compressed_account_to_circuit_inputs(
    inputs: &mut HashMap<String, Vec<String>>,
    compressed_account: &CompressedAccount,
    merkle_tree_pubkey: &Pubkey,
    leaf_index: u32,
) {
    let owner = compressed_account.owner;
    let (discriminator, data_hash) = if let Some(ref data) = compressed_account.data {
        (data.discriminator, data.data_hash)
    } else {
        ([0u8; 8], [0u8; 32])
    };

    let owner_hashed = hash_to_bn254_field_size_be(owner.as_ref());
    let merkle_tree_hashed = hash_to_bn254_field_size_be(merkle_tree_pubkey.as_ref());

    inputs.insert(
        "owner_hashed".to_string(),
        vec![BigUint::from_bytes_be(&owner_hashed).to_string()],
    );
    inputs.insert("leaf_index".to_string(), vec![leaf_index.to_string()]);
    inputs.insert(
        "merkle_tree_hashed".to_string(),
        vec![BigUint::from_bytes_be(&merkle_tree_hashed).to_string()],
    );
    inputs.insert(
        "discriminator".to_string(),
        vec![BigUint::from_bytes_be(&discriminator).to_string()],
    );
    inputs.insert(
        "data_hash".to_string(),
        vec![BigUint::from_bytes_be(&data_hash).to_string()],
    );

    println!("Public inputs (in circuit order):");
    println!("  [0] owner_hashed: {:?}", owner_hashed);
    println!("  [1] merkle_tree_hashed: {:?}", merkle_tree_hashed);
    println!("  [2] discriminator: {:?}", discriminator);
    println!("  [3] data_hash: {:?}", data_hash);
}

/// Helper function to add Merkle proof inputs to the circuit inputs HashMap
fn add_merkle_proof_to_circuit_inputs(
    inputs: &mut HashMap<String, Vec<String>>,
    merkle_proof_hashes: &[[u8; 32]],
    merkle_root: &[u8; 32],
) {
    let path_elements: Vec<String> = merkle_proof_hashes
        .iter()
        .map(|hash| BigUint::from_bytes_be(hash).to_string())
        .collect();
    inputs.insert("pathElements".to_string(), path_elements);

    let expected_root_bigint = BigUint::from_bytes_be(merkle_root);
    inputs.insert(
        "expectedRoot".to_string(),
        vec![expected_root_bigint.to_string()],
    );

    println!("  [4] expectedRoot: {:?}", merkle_root);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_compressed_account_proof_with_groth16_solana() {
        let zkey_path = "./build/compressed_account_merkle_proof_final.zkey".to_string();

        // Create compressed account
        let owner = Pubkey::new_from_array([1u8; 32]);
        let merkle_tree_pubkey = Pubkey::new_from_array([2u8; 32]);
        let leaf_index: u32 = 0;

        let compressed_account = CompressedAccount {
            owner,
            lamports: 0,
            address: None,
            data: Some(CompressedAccountData {
                discriminator: [1u8; 8],
                data: vec![],
                data_hash: [3u8; 32],
            }),
        };

        // Create Merkle tree and get proof
        let compressed_account_hash = compressed_account
            .hash(&merkle_tree_pubkey, &leaf_index, false)
            .unwrap();

        let mut merkle_tree = MerkleTree::<Poseidon>::new(26, 0);
        merkle_tree.append(&compressed_account_hash).unwrap();

        let merkle_proof_hashes = merkle_tree
            .get_proof_of_leaf(leaf_index as usize, false)
            .unwrap();
        let merkle_root = merkle_tree.root();

        // Build circuit inputs
        let mut proof_inputs = HashMap::new();
        add_compressed_account_to_circuit_inputs(
            &mut proof_inputs,
            &compressed_account,
            &merkle_tree_pubkey,
            leaf_index,
        );
        add_merkle_proof_to_circuit_inputs(&mut proof_inputs, &merkle_proof_hashes, &merkle_root);

        // Generate proof using circom-prover
        let circuit_inputs = serde_json::to_string(&proof_inputs).unwrap();
        let proof = CircomProver::prove(
            ProofLib::Arkworks,
            WitnessFn::RustWitness(compressedaccountmerkleproof_witness),
            circuit_inputs,
            zkey_path.clone(),
        )
        .expect("Proof generation failed");
        println!(
            "Proof generated successfully with circom-prover {:?}",
            proof
        );
        // First verify the proof with circom-prover to ensure it's valid
        let is_valid_circom =
            CircomProver::verify(ProofLib::Arkworks, proof.clone(), zkey_path.clone())
                .expect("Circom proof verification failed");
        assert!(
            is_valid_circom,
            "Proof should be valid according to circom-prover"
        );
        println!("Proof verified successfully with circom-prover");

        // Convert proof and public inputs to groth16-solana format
        let (proof_a, proof_b, proof_c) =
            convert_proof(&proof.proof).expect("Failed to convert proof to groth16-solana format");
        let public_inputs: [[u8; 32]; 5] = convert_public_inputs(&proof.pub_inputs);
        println!("Public inputs for groth16-solana: {:?}", public_inputs);
        println!("Proof A: {:?}", proof_a);
        println!("Proof B: {:?}", proof_b);
        println!("Proof C: {:?}", proof_c);
        let mut verifier =
            Groth16Verifier::new(&proof_a, &proof_b, &proof_c, &public_inputs, &VERIFYINGKEY)
                .expect("Failed to create verifier");

        verifier.verify().expect("Proof verification failed");

        println!("Proof verified successfully with groth16-solana!");
    }
}
